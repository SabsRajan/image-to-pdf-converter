<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Easy Image To PDF Converter - Deluxe Edition</title>
    <!-- Tailwind CSS for layout utilities -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Google Fonts: Patrick Hand for a bold, fun handwritten look -->
    <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap" rel="stylesheet">
    
    <style>
        /* --- CSS ART & ATMOSPHERE --- */
        :root {
            --wood-primary: #8b5a2b;
            --wood-secondary: #5c3a1e;
            --paper-color: #fdfbf7;
            --shadow-soft: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-deep: 0 20px 25px -5px rgba(0, 0, 0, 0.3), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
        }

        body {
            margin: 0;
            /* Allow scrolling for mobile layouts */
            overflow-y: auto; 
            overflow-x: hidden;
            font-family: 'Patrick Hand', cursive; 
            font-size: 18px;
            background-color: var(--wood-primary);
            /* Realistic Wood Texture */
            background-image: 
                repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 10px),
                linear-gradient(to bottom, rgba(0,0,0,0.1), rgba(0,0,0,0.3)),
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.15'/%3E%3C/svg%3E");
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1000px;
            user-select: none;
        }

        /* --- DESK ITEMS (CSS ART) --- */
        .desk-item {
            position: absolute;
            z-index: 5;
        }

        .ruler {
            width: 320px;
            height: 50px;
            background: #e6c200;
            top: 10%;
            left: 10%;
            transform: rotate(15deg);
            border-radius: 4px;
            box-shadow: 4px 4px 8px rgba(0,0,0,0.4);
            background-image: linear-gradient(90deg, transparent 95%, #000 95%);
            background-size: 20px 100%;
            cursor: grab;
            transition: transform 0.1s;
        }
        .ruler:active { cursor: grabbing; transform: scale(1.02) rotate(15deg); }

        .coffee-stain {
            width: 140px;
            height: 140px;
            border: 12px solid rgba(66, 42, 22, 0.2);
            border-radius: 50%;
            bottom: 10%;
            right: 5%;
            transform: scale(1) skew(5deg);
            filter: blur(2px);
            cursor: pointer;
            transition: all 0.3s;
        }
        .coffee-stain:active { transform: scale(0.95) skew(5deg); border-color: rgba(66, 42, 22, 0.4); }

        .pencil {
            width: 240px;
            height: 18px;
            background: #ffcc00;
            bottom: 15%;
            left: 20%;
            transform: rotate(-10deg);
            border-radius: 2px;
            box-shadow: 3px 3px 5px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        .pencil::after {
            content: '';
            position: absolute;
            right: -14px;
            top: 0;
            border-left: 14px solid #f0dca0;
            border-top: 9px solid transparent;
            border-bottom: 9px solid transparent;
        }
        .pencil::before { /* Lead */
            content: '';
            position: absolute;
            right: -18px;
            top: 6px;
            border-left: 6px solid #333;
            border-top: 3px solid transparent;
            border-bottom: 3px solid transparent;
        }
        .pencil.wiggle { animation: wiggle 0.5s ease-in-out; }
        @keyframes wiggle { 0%, 100% {transform: rotate(-10deg);} 25% {transform: rotate(-15deg);} 75% {transform: rotate(-5deg);} }

        /* --- MAIN INTERFACE --- */
        .app-container {
            display: flex;
            flex-direction: row;
            gap: 3rem;
            z-index: 10;
            position: relative;
            transform-style: preserve-3d;
            padding: 2rem;
            align-items: flex-start;
        }

        .paper-sheet {
            background-color: var(--paper-color);
            width: 340px;
            min-height: 500px;
            padding: 2.5rem 2rem;
            position: relative;
            box-shadow: var(--shadow-deep);
            border-radius: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.27);
        }

        /* --- RESPONSIVE MEDIA QUERY --- */
        @media (max-width: 850px) {
            .app-container {
                flex-direction: column;
                gap: 2rem;
                padding-top: 4rem; /* Space for items */
                align-items: center;
            }
            
            .paper-sheet {
                width: 90%;
                max-width: 340px;
                min-height: auto; /* Allow flexible height */
            }

            /* Move desk items out of the way on mobile */
            .ruler { top: 2%; left: 50%; transform: translateX(-50%) rotate(0deg); width: 90%; }
            .pencil { bottom: auto; top: 15%; left: -10%; transform: rotate(45deg); z-index: 4; }
            .coffee-stain { bottom: 2%; right: -10%; z-index: 4; }
        }
        
        /* Notebook lines */
        .paper-sheet::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image: linear-gradient(#d1d5db 1px, transparent 1px);
            background-size: 100% 1.5rem;
            pointer-events: none;
            opacity: 0.6;
            z-index: 0;
            margin-top: 4rem;
        }
        
        /* Red margin line */
        .paper-sheet::after {
            content: '';
            position: absolute;
            top: 0; bottom: 0; left: 3.5rem;
            width: 2px;
            background-color: rgba(239, 68, 68, 0.4);
            pointer-events: none;
            z-index: 0;
        }

        /* Tape effect */
        .tape {
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%) rotate(-2deg);
            width: 100px;
            height: 30px;
            background-color: rgba(255, 255, 255, 0.6);
            border-left: 1px solid rgba(255, 255, 255, 0.4);
            border-right: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 1px 2px rgba(0,0,0,0.15);
            backdrop-filter: blur(2px);
            z-index: 20;
        }

        .content-layer {
            position: relative;
            z-index: 10;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
        }

        h2 {
            font-size: 2rem;
            font-weight: 800;
            color: #111827;
            margin-bottom: 1.5rem;
            text-align: center;
            position: relative;
            display: inline-block;
            background: linear-gradient(120deg, rgba(250, 204, 21, 0.8) 0%, rgba(250, 204, 21, 0.8) 100%);
            background-repeat: no-repeat;
            background-size: 100% 45%;
            background-position: 0 80%;
            padding: 0 8px;
            transform: rotate(-1deg);
        }

        /* --- UPLOAD SECTION --- */
        .drop-zone {
            width: 100%;
            height: 150px;
            border: 4px dashed #6b7280;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(255,255,255,0.85);
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }

        .drop-zone:hover { 
            border-color: #f59e0b;
            background: #fffbeb; 
            transform: scale(1.02);
        }
        .drop-zone.active { 
            border-color: #16a34a; 
            background: #dcfce7; 
            transform: scale(1.02);
        }

        /* Polaroid Thumbnails */
        .thumbnail-stack {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 1.5rem;
            width: 100%;
            min-height: 80px;
        }

        .polaroid {
            background: white;
            padding: 5px 5px 18px 5px;
            box-shadow: 2px 4px 6px rgba(0,0,0,0.15);
            transform: rotate(var(--rot));
            transition: transform 0.2s, opacity 0.3s;
            position: relative;
            cursor: grab;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.27);
            border: 1px solid #e5e7eb;
        }
        .polaroid:active { cursor: grabbing; }
        .polaroid img {
            width: 100%;
            height: 60px;
            object-fit: cover;
            border: 1px solid #eee;
            background: #f0f0f0;
        }
        
        .polaroid::before {
            content: '';
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            width: 14px;
            height: 30px;
            border: 3px solid #374151;
            border-radius: 12px;
            z-index: -1;
        }

        .polaroid-actions {
            position: absolute;
            bottom: 2px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            padding: 0 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .polaroid:hover { z-index: 20; transform: scale(1.15) rotate(0deg) !important; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2); }
        .polaroid:hover .polaroid-actions { opacity: 1; }

        .action-btn {
            font-size: 16px;
            background: white;
            border: 1px solid #999;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #555;
            font-weight: bold;
            box-shadow: 0 2px 2px rgba(0,0,0,0.1);
        }
        .action-btn:hover { color: white; background: #ef4444; border-color: #ef4444; scale: 1.1; }

        @keyframes crumble {
            0% { transform: scale(1); }
            50% { transform: scale(0.5) rotate(180deg); opacity: 0.8; }
            100% { transform: scale(0) rotate(720deg); opacity: 0; }
        }
        .crumpled { animation: crumble 0.6s forwards ease-in; }

        /* --- SCANNER EFFECT --- */
        .scanner-bar {
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 15px;
            background: linear-gradient(to bottom, rgba(59, 130, 246, 0.6), transparent);
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.8);
            z-index: 50;
            opacity: 0;
            pointer-events: none;
        }
        .scanning { animation: scan 2s linear infinite; opacity: 1; }
        @keyframes scan {
            0% { top: 0%; }
            100% { top: 100%; }
        }

        /* --- CONTROLS --- */
        .controls-area {
            margin-top: auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .quality-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1rem;
            color: #374151;
            font-weight: bold;
            cursor: pointer;
            background: white;
            padding: 6px;
            border-radius: 8px;
            border: 2px solid #e5e7eb;
            box-shadow: 0 2px 0 #d1d5db;
        }
        .quality-toggle:hover { border-color: #cbd5e1; }
        
        .toggle-switch {
            width: 36px;
            height: 20px;
            background: #94a3b8;
            border-radius: 99px;
            position: relative;
            transition: background 0.2s;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            left: 3px; top: 3px;
            width: 14px; height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .quality-active .toggle-switch { background: #16a34a; }
        .quality-active .toggle-switch::after { transform: translateX(16px); }

        .btn-primary {
            background: #1f2937;
            color: #f9fafb;
            padding: 0.8rem 1.5rem;
            border-radius: 6px;
            font-weight: 800;
            font-size: 1.1rem;
            box-shadow: 0 4px 0 #000;
            transition: all 0.1s;
            border: 2px solid #000;
            cursor: pointer;
            width: 100%;
            font-family: inherit;
            position: relative;
            overflow: hidden;
            letter-spacing: 0.5px;
        }
        .btn-primary:active { transform: translateY(4px); box-shadow: 0 0 0 transparent; }
        .btn-primary:disabled { 
            background: #9ca3af; 
            box-shadow: none; 
            border-color: #6b7280; 
            color: #e5e7eb;
            cursor: not-allowed; 
            transform: none; 
        }
        .btn-download {
            background-color: #b91c1c; 
            border-color: #7f1d1d;
            box-shadow: 0 4px 0 #7f1d1d;
        }
        .btn-download:active { box-shadow: none; }

        /* --- OUTPUT SECTION --- */
        .result-placeholder {
            width: 100%;
            height: 240px;
            background: rgba(255,255,255,0.5);
            border: 3px dotted #9ca3af;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-style: italic;
            font-weight: 600;
        }

        .stamp-animation {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(3);
            opacity: 0;
            border: 6px solid #b91c1c;
            color: #b91c1c;
            padding: 0.5rem 1rem;
            font-weight: 900;
            font-size: 2rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-radius: 12px;
            pointer-events: none;
            z-index: 50;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            mask-image: url("data:image/svg+xml,%3Csvg width='200' height='100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.7'/%3E%3C/svg%3E");
        }
        .stamp-active { animation: stampDown 0.4s cubic-bezier(0.6, 0.04, 0.98, 0.335) forwards; }
        @keyframes stampDown {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(3); }
            70% { opacity: 1; transform: translate(-50%, -50%) scale(0.9); }
            100% { opacity: 0.9; transform: translate(-50%, -50%) scale(1) rotate(-5deg); }
        }

        .toast {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #1f2937;
            color: white;
            padding: 0.75rem 2rem;
            border-radius: 999px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s;
            z-index: 100;
            font-weight: bold;
            font-size: 1.1rem;
            border: 2px solid white;
        }
        .toast.show { transform: translateX(-50%) translateY(0); }

        @keyframes popIn {
            from { transform: scale(0) rotate(0); }
            to { transform: scale(1) rotate(var(--rot)); }
        }

    </style>
</head>
<body>
    
    <!-- Interactive Desk Items -->
    <div class="desk-item ruler" id="ruler"></div>
    <div class="desk-item coffee-stain" id="coffee"></div>
    <div class="desk-item pencil" id="pencil"></div>

    <div class="app-container">
        
        <!-- Window 1: Upload & Edit -->
        <div class="paper-sheet" id="upload-sheet">
            <div class="tape"></div>
            <!-- Scanner Beam -->
            <div class="scanner-bar" id="scanner-bar"></div>

            <div class="content-layer">
                <h2>Collect & Edit</h2>
                
                <div class="drop-zone" id="drop-zone">
                    <svg class="w-10 h-10 text-gray-500 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5"><path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                    <p class="text-lg text-gray-700 font-bold text-center px-4">Drag JPG/PNG here</p>
                    <p class="text-sm text-gray-500 font-bold">(Max 6)</p>
                    <input type="file" id="file-input" accept="image/jpeg, image/png" multiple class="hidden">
                </div>

                <div class="thumbnail-stack" id="thumbnail-stack">
                    <!-- Polaroids injected here -->
                </div>
                
                <div class="controls-area">
                    <p id="count-label" class="text-center text-sm text-gray-500 font-bold font-mono tracking-widest">0 / 6 IMAGES</p>
                    
                    <div class="quality-toggle" id="quality-btn">
                        <span>Small File</span>
                        <div class="toggle-switch"></div>
                        <span>High Quality</span>
                    </div>

                    <button id="convert-btn" class="btn-primary" disabled>
                        PROCESS DOCS
                    </button>
                </div>
            </div>
        </div>

        <!-- Window 2: Result -->
        <div class="paper-sheet" id="result-sheet">
            <div class="tape"></div>
            <div class="content-layer">
                <h2>Final PDF</h2>
                
                <div class="result-placeholder" id="result-placeholder">
                    <div class="text-center p-4">
                        <svg class="w-12 h-12 mx-auto text-gray-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path></svg>
                        <p class="text-lg text-gray-500">Result will appear here</p>
                    </div>
                </div>

                <!-- PDF Preview Container -->
                <div id="pdf-preview" class="hidden w-full h-64 bg-gray-100 border-2 border-gray-300 rounded-lg overflow-hidden flex items-center justify-center relative shadow-inner">
                    <div class="stamp-animation" id="stamp">DONE!</div>
                    <img src="" id="preview-img" class="h-full object-contain shadow-md bg-white">
                </div>

                <div class="mt-auto w-full">
                    <button id="download-btn" class="btn-primary btn-download" disabled>
                        DOWNLOAD PDF
                    </button>
                    <button id="reset-btn" class="mt-3 w-full text-sm text-gray-500 hover:text-gray-900 font-bold underline decoration-2 decoration-gray-400 hover:decoration-black">Clean Desk (Reset)</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="toast">Message here</div>

    <script>
        // --- SOUND ENGINE ---
        class SoundEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);
            }

            resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }

            playNoise(duration, type = 'lowpass', freq = 800) {
                this.resume();
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = this.ctx.createBiquadFilter();
                filter.type = type;
                filter.frequency.value = freq;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            playPaper() { this.playNoise(0.3, 'lowpass', 800); }
            playCrumple() { this.playNoise(0.4, 'highpass', 500); }
            playSip() { 
                this.resume();
                // Simple bubbly sound
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                osc.connect(gain).connect(this.masterGain);
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            }
            playClack() {
                this.resume();
                // Sharp wood click
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(300, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                osc.connect(gain).connect(this.masterGain);
                osc.start(); osc.stop(this.ctx.currentTime + 0.05);
            }
            playScannerHum() {
                this.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 50;
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2.0);
                osc.connect(gain).connect(this.masterGain);
                osc.start(); osc.stop(this.ctx.currentTime + 2.0);
            }
            playStamp() {
                this.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(150, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                osc.connect(gain).connect(this.masterGain);
                osc.start(); osc.stop(this.ctx.currentTime + 0.2);
            }
        }
        const audio = new SoundEngine();

        // --- STATE ---
        const state = {
            images: [], // { id, data, fileType }
            maxImages: 6,
            highQuality: true,
            pdfBlob: null
        };

        // --- DOM ---
        const els = {
            dropZone: document.getElementById('drop-zone'),
            fileInput: document.getElementById('file-input'),
            stack: document.getElementById('thumbnail-stack'),
            convertBtn: document.getElementById('convert-btn'),
            qualityBtn: document.getElementById('quality-btn'),
            scanner: document.getElementById('scanner-bar'),
            resultSheet: document.getElementById('result-sheet'),
            previewDiv: document.getElementById('pdf-preview'),
            previewImg: document.getElementById('preview-img'),
            stamp: document.getElementById('stamp'),
            downloadBtn: document.getElementById('download-btn'),
            resetBtn: document.getElementById('reset-btn'),
            count: document.getElementById('count-label'),
            toast: document.getElementById('toast'),
            ruler: document.getElementById('ruler'),
            pencil: document.getElementById('pencil'),
            coffee: document.getElementById('coffee')
        };

        // --- INTERACTIVE DESK ITEMS ---
        // Ruler Drag
        let isDragging = false;
        let startX, startY, initialLeft, initialTop;
        
        els.ruler.addEventListener('mousedown', (e) => {
            isDragging = true;
            startX = e.clientX;
            startY = e.clientY;
            const rect = els.ruler.getBoundingClientRect();
            // Use offsetLeft/Top relative to parent
            initialLeft = els.ruler.offsetLeft;
            initialTop = els.ruler.offsetTop;
            els.ruler.style.cursor = 'grabbing';
            audio.playClack();
        });

        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            els.ruler.style.left = `${initialLeft + dx}px`;
            els.ruler.style.top = `${initialTop + dy}px`;
        });

        window.addEventListener('mouseup', () => {
            if (isDragging) audio.playClack();
            isDragging = false;
            els.ruler.style.cursor = 'grab';
        });

        // Pencil & Coffee
        els.pencil.addEventListener('click', () => {
            audio.playClack();
            els.pencil.classList.add('wiggle');
            setTimeout(() => els.pencil.classList.remove('wiggle'), 500);
        });
        
        els.coffee.addEventListener('click', () => {
            audio.playSip();
        });


        // --- MAIN APP LOGIC ---
        
        // Init Quality State in UI
        if(state.highQuality) els.qualityBtn.classList.add('quality-active');

        // Quality Toggle
        els.qualityBtn.addEventListener('click', () => {
            state.highQuality = !state.highQuality;
            els.qualityBtn.classList.toggle('quality-active', state.highQuality);
            audio.playClack();
        });

        // Upload
        els.dropZone.addEventListener('click', () => els.fileInput.click());
        els.dropZone.addEventListener('dragover', (e) => { e.preventDefault(); els.dropZone.classList.add('active'); });
        els.dropZone.addEventListener('dragleave', () => els.dropZone.classList.remove('active'));
        els.dropZone.addEventListener('drop', handleDrop);
        els.fileInput.addEventListener('change', (e) => processFiles(e.target.files));

        function handleDrop(e) {
            e.preventDefault();
            els.dropZone.classList.remove('active');
            processFiles(e.dataTransfer.files);
        }

        function processFiles(files) {
            if (state.images.length >= state.maxImages) return showToast("Desk full! Max 6 images.");
            
            // Only allow JPG and PNG
            const validTypes = ['image/jpeg', 'image/png'];

            Array.from(files).forEach(file => {
                if (!validTypes.includes(file.type)) {
                    showToast("Only JPG or PNG allowed!");
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (state.images.length >= state.maxImages) return;
                    
                    // Normalize file type for jsPDF
                    let type = file.type.split('/')[1].toUpperCase();
                    if (type === 'JPG') type = 'JPEG';
                    
                    state.images.push({
                        id: Date.now() + Math.random(),
                        data: e.target.result,
                        fileType: type
                    });
                    renderThumbnails();
                    audio.playPaper();
                };
                reader.readAsDataURL(file);
            });
            els.fileInput.value = '';
        }

        // Thumbnail Rendering & Reordering
        let draggedItem = null;

        function renderThumbnails() {
            els.stack.innerHTML = '';
            els.count.innerText = `${state.images.length} / ${state.maxImages} IMAGES`;
            els.convertBtn.disabled = state.images.length === 0;
            if (state.images.length === 0) els.convertBtn.classList.remove('bg-gray-800');

            state.images.forEach((imgObj, index) => {
                const div = document.createElement('div');
                div.className = 'polaroid';
                div.draggable = true;
                div.style.setProperty('--rot', (Math.random() * 6 - 3) + 'deg');
                
                // Drag Events
                div.addEventListener('dragstart', () => { draggedItem = index; div.style.opacity = '0.5'; });
                div.addEventListener('dragend', () => { draggedItem = null; div.style.opacity = '1'; });
                div.addEventListener('dragover', (e) => e.preventDefault());
                div.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (draggedItem === null || draggedItem === index) return;
                    // Reorder
                    const item = state.images.splice(draggedItem, 1)[0];
                    state.images.splice(index, 0, item);
                    renderThumbnails();
                    audio.playPaper();
                });

                // Image content
                const img = document.createElement('img');
                img.src = imgObj.data;

                // Actions
                const actions = document.createElement('div');
                actions.className = 'polaroid-actions';
                
                const delBtn = document.createElement('button');
                delBtn.className = 'action-btn btn-delete';
                delBtn.innerHTML = 'âœ•';
                delBtn.title = 'Remove';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteImage(index, div);
                };

                actions.appendChild(delBtn);
                div.appendChild(img);
                div.appendChild(actions);
                els.stack.appendChild(div);
            });
        }

        function deleteImage(index, element) {
            element.classList.add('crumpled');
            audio.playCrumple();
            setTimeout(() => {
                state.images.splice(index, 1);
                renderThumbnails();
            }, 600);
        }

        // PDF Generation
        els.convertBtn.addEventListener('click', generatePDF);

        async function generatePDF() {
            if (state.images.length === 0) return;

            // Start Scanner Animation
            els.convertBtn.disabled = true;
            els.convertBtn.innerText = "SCANNING...";
            els.scanner.classList.add('scanning');
            audio.playScannerHum();

            await new Promise(r => setTimeout(r, 2000));

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                const pageWidth = 210; 
                const pageHeight = 297; 
                const margin = 10;
                
                // Helper: Robust Image Loader with Decode
                const loadImage = (src) => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = async () => {
                        try {
                            // Critical Fix: Force browser to decode bitmap before drawing
                            await img.decode();
                        } catch (e) {
                            console.warn("Image decode warning, proceeding anyway", e);
                        }
                        resolve(img);
                    };
                    img.onerror = () => reject(new Error("Failed to load image"));
                    img.src = src;
                });

                for (let i = 0; i < state.images.length; i++) {
                    if (i > 0) doc.addPage();
                    
                    const item = state.images[i];
                    let imgDataForPdf = item.data;
                    let imgType = item.fileType;
                    let finalW, finalH;

                    // --- STRATEGY 1: DIRECT PASS (Best Quality) ---
                    // Used when "High Quality" is on AND image is a standard format
                    if (state.highQuality && (imgType === 'JPEG' || imgType === 'PNG')) {
                        
                        const img = await loadImage(item.data);
                        
                        // Use natural dimensions for accuracy
                        const w = img.naturalWidth || img.width;
                        const h = img.naturalHeight || img.height;
                        
                        const imgRatio = w / h;
                        const pageRatio = (pageWidth - margin*2) / (pageHeight - margin*2);
                        
                        if (imgRatio > pageRatio) {
                            finalW = pageWidth - margin*2;
                            finalH = finalW / imgRatio;
                        } else {
                            finalH = pageHeight - margin*2;
                            finalW = finalH * imgRatio;
                        }
                        
                        doc.addImage(item.data, imgType, (pageWidth - finalW)/2, (pageHeight - finalH)/2, finalW, finalH);
                    
                    } else {
                        // --- STRATEGY 2: CANVAS PASS (Small File / Fallback) ---
                        // Used for "Small File" mode OR unsupported formats
                        
                        const img = await loadImage(item.data);

                        // Fix: Use naturalWidth/Height to avoid 0x0 issues
                        const srcW = img.naturalWidth || img.width;
                        const srcH = img.naturalHeight || img.height;

                        // Resize logic
                        const MAX_DIMENSION = 800; 
                        let targetW = srcW;
                        let targetH = srcH;
                        
                        if (srcW > MAX_DIMENSION || srcH > MAX_DIMENSION) {
                            const ratio = Math.min(MAX_DIMENSION / srcW, MAX_DIMENSION / srcH);
                            targetW = Math.floor(srcW * ratio);
                            targetH = Math.floor(srcH * ratio);
                        }
                        
                        const canvas = document.createElement('canvas');
                        canvas.width = targetW;
                        canvas.height = targetH;
                        
                        // Fix: Optimization hint for frequent reads
                        const ctx = canvas.getContext('2d', { willReadFrequently: true });

                        // 1. Fill White (Fix for transparency becoming black)
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // 2. Draw Image with Explicit Coordinates
                        // Fix: Explicitly mapping source rect to destination rect ensures data is copied correctly
                        ctx.drawImage(img, 0, 0, srcW, srcH, 0, 0, targetW, targetH);

                        const newData = canvas.toDataURL('image/jpeg', 0.5); 
                        
                        const imgRatio = targetW / targetH;
                        const pageRatio = (pageWidth - margin*2) / (pageHeight - margin*2);
                        
                        if (imgRatio > pageRatio) {
                            finalW = pageWidth - margin*2;
                            finalH = finalW / imgRatio;
                        } else {
                            finalH = pageHeight - margin*2;
                            finalW = finalH * imgRatio;
                        }

                        doc.addImage(newData, 'JPEG', (pageWidth - finalW)/2, (pageHeight - finalH)/2, finalW, finalH);
                    }
                }

                state.pdfBlob = doc.output('blob');

                // Finish
                els.scanner.classList.remove('scanning');
                els.convertBtn.innerText = "PROCESS DOCS";
                
                document.getElementById('result-placeholder').style.display = 'none';
                els.previewDiv.classList.remove('hidden');
                els.previewDiv.style.display = 'flex';
                els.previewImg.src = state.images[0].data; 
                
                setTimeout(() => {
                    els.stamp.classList.add('stamp-active');
                    audio.playStamp();
                    els.downloadBtn.disabled = false;
                }, 100);

            } catch (err) {
                console.error(err);
                showToast("Error! Check console.");
                els.scanner.classList.remove('scanning');
                els.convertBtn.disabled = false;
                els.convertBtn.innerText = "PROCESS DOCS";
            }
        }

        // Download & Reset
        els.downloadBtn.addEventListener('click', () => {
            if (!state.pdfBlob) return;
            const a = document.createElement('a');
            a.href = URL.createObjectURL(state.pdfBlob);
            a.download = `Scanned_Docs_${new Date().toLocaleTimeString()}.pdf`;
            a.click();
            audio.playPaper();
        });

        els.resetBtn.addEventListener('click', () => {
            state.images = [];
            state.pdfBlob = null;
            els.fileInput.value = ''; 
            els.previewImg.src = ''; 
            renderThumbnails();
            
            els.previewDiv.style.display = 'none'; 
            els.previewDiv.classList.add('hidden');
            
            document.getElementById('result-placeholder').style.display = 'flex';
            els.stamp.classList.remove('stamp-active');
            els.downloadBtn.disabled = true;
            audio.playPaper();
        });

        function showToast(msg) {
            els.toast.innerText = msg;
            els.toast.classList.add('show');
            setTimeout(() => els.toast.classList.remove('show'), 3000);
        }

    </script>
</body>
</html>